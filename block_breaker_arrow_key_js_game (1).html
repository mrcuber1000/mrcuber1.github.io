<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Block Breaker (Arrow Keys)</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#7dd3fc;--muted:#94a3b8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071022 0%, #0f1724 100%);color:#e6eef8}
    .wrap{width:880px;max-width:95%;padding:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.7)}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
    h1{font-size:18px;margin:0}
    .meta{color:var(--muted);font-size:13px}
    #gameCanvas{display:block;background:#071226;border-radius:8px;width:100%;height:600px}
    .controls{display:flex;gap:8px;align-items:center;margin-top:10px}
    .btn{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 12px;border-radius:8px;color:var(--muted);cursor:pointer}
    .hint{color:var(--muted);font-size:13px}
    footer{margin-top:12px;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Block Breaker — use ◀️ / ▶️ (arrow keys)</h1>
        <div class="meta">Move paddle with left/right arrows. Press Space to launch ball / restart.</div>
      </div>
      <div class="meta" id="scoreBoard">Score: 0 &nbsp;&nbsp; Lives: 3</div>
    </header>

    <canvas id="gameCanvas" width="880" height="600"></canvas>

    <div class="controls">
      <button class="btn" id="startBtn">Start / Restart (Space)</button>
      <div class="hint">Tip: Hold arrow keys for smooth movement. Break all blocks to win.</div>
    </div>
    <footer>Made with plain HTML5 canvas and JavaScript.</footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width; const H = canvas.height;

  // Game state
  let leftPressed = false, rightPressed = false;
  let score = 0, lives = 3;
  let gameTime = 0; // keeps track of frames passed

  // Paddle
  const paddle = { w:120, h:14, x: (W-120)/2, y: H-40, speed: 7 };

  // Ball
  const ball = { r:9, x: W/2, y: paddle.y - 9 - 1, vx:0, vy:0, speed:5, stuck:true };

  // Bricks
  const brick = { rows:5, cols:11, w: Math.floor((W-120)/11), h:22, padding:8, offsetTop:60, offsetLeft:60 };
  let bricks = [];

  function initBricks(){
    bricks = [];
    for(let r=0;r<brick.rows;r++){
      const row = [];
      for(let c=0;c<brick.cols;c++){
        const x = brick.offsetLeft + c*(brick.w + brick.padding);
        const y = brick.offsetTop + r*(brick.h + brick.padding);
        row.push({ x,y, w:brick.w, h:brick.h, alive:true, hits:1 });
      }
      bricks.push(row);
    }
  }

  function resetGame(){
    score = 0; lives = 3; paddle.x = (W-paddle.w)/2;
    ball.r = 9; ball.x = W/2; ball.y = paddle.y - ball.r - 1; ball.vx = 0; ball.vy = 0; ball.speed = 5; ball.stuck = true;
    paddle.speed = 7;
    gameTime = 0;
    initBricks(); updateScoreBoard();
  }

  function launchBall(){
    if(!ball.stuck) return;
    const angle = (Math.random()*Math.PI/3) + (Math.PI/6); // 30-90 degrees
    const dir = Math.random() < 0.5 ? -1 : 1;
    ball.vx = dir * ball.speed * Math.cos(angle);
    ball.vy = -Math.abs(ball.speed * Math.sin(angle));
    ball.stuck = false;
  }

  function updateScoreBoard(){
    document.getElementById('scoreBoard').textContent = `Score: ${score}   Lives: ${lives}`;
  }

  // Input
  window.addEventListener('keydown', e => {
    if(e.code === 'ArrowLeft') leftPressed = true;
    if(e.code === 'ArrowRight') rightPressed = true;
    if(e.code === 'Space'){
      e.preventDefault();
      if(ball.stuck) launchBall();
      else if(lives <= 0 || isWin()) resetGame();
    }
  });
  window.addEventListener('keyup', e => {
    if(e.code === 'ArrowLeft') leftPressed = false;
    if(e.code === 'ArrowRight') rightPressed = false;
  });

  // For Start button
  document.getElementById('startBtn').addEventListener('click', ()=>{
    resetGame();
  });

  // Collision helpers
  function rectCircleColliding(circle, rect){
    const distX = Math.abs(circle.x - rect.x - rect.w/2);
    const distY = Math.abs(circle.y - rect.y - rect.h/2);
    if (distX > (rect.w/2 + circle.r)) return false;
    if (distY > (rect.h/2 + circle.r)) return false;
    if (distX <= (rect.w/2)) return true;
    if (distY <= (rect.h/2)) return true;
    const dx = distX - rect.w/2;
    const dy = distY - rect.h/2;
    return (dx*dx + dy*dy <= (circle.r*circle.r));
  }

  function isWin(){
    for(let r=0;r<bricks.length;r++) for(let c=0;c<bricks[r].length;c++) if(bricks[r][c].alive) return false;
    return true;
  }

  function update(){
    gameTime++;

    // Slowly increase difficulty every 600 frames (~10s at 60fps)
    if(gameTime % 600 === 0){
      ball.speed = Math.min(ball.speed + 0.5, 15);
      paddle.speed = Math.min(paddle.speed + 0.3, 15);
      // Normalize velocity to new speed if ball is moving
      if(!ball.stuck){
        const angle = Math.atan2(ball.vy, ball.vx);
        ball.vx = Math.cos(angle) * ball.speed;
        ball.vy = Math.sin(angle) * ball.speed;
      }
    }

    // Paddle movement
    if(leftPressed) paddle.x -= paddle.speed;
    if(rightPressed) paddle.x += paddle.speed;
    paddle.x = Math.max(0, Math.min(W - paddle.w, paddle.x));

    // Keep ball on paddle if stuck
    if(ball.stuck){
      ball.x = paddle.x + paddle.w/2;
      ball.y = paddle.y - ball.r - 1;
    } else {
      ball.x += ball.vx;
      ball.y += ball.vy;

      // Wall collisions
      if(ball.x - ball.r < 0){ ball.x = ball.r; ball.vx *= -1; }
      if(ball.x + ball.r > W){ ball.x = W - ball.r; ball.vx *= -1; }
      if(ball.y - ball.r < 0){ ball.y = ball.r; ball.vy *= -1; }

      // Paddle collision - reflect based on where it hit the paddle
      const paddleRect = { x: paddle.x, y: paddle.y, w: paddle.w, h: paddle.h };
      if(rectCircleColliding(ball, paddleRect) && ball.vy > 0){
        const relative = (ball.x - (paddle.x + paddle.w/2)) / (paddle.w/2);
        const bounceAngle = relative * (Math.PI/3);
        const speed = Math.min(15, Math.hypot(ball.vx, ball.vy));
        ball.vx = speed * Math.sin(bounceAngle);
        ball.vy = -Math.abs(speed * Math.cos(bounceAngle));
      }

      // Brick collisions
      outer: for(let r=0;r<bricks.length;r++){
        for(let c=0;c<bricks[r].length;c++){
          const b = bricks[r][c];
          if(!b.alive) continue;
          const rect = { x:b.x, y:b.y, w:b.w, h:b.h };
          if(rectCircleColliding(ball, rect)){
            const prevX = ball.x - ball.vx;
            const prevY = ball.y - ball.vy;
            let collidedHoriz = false;
            if(prevX + ball.r <= rect.x || prevX - ball.r >= rect.x + rect.w) collidedHoriz = true;
            if(collidedHoriz) ball.vx *= -1; else ball.vy *= -1;
            b.alive = false;
            score += 10;
            updateScoreBoard();
            break outer;
          }
        }
      }

      // Bottom - lose life
      if(ball.y - ball.r > H){
        lives -= 1;
        updateScoreBoard();
        if(lives <= 0){
          ball.stuck = true; ball.vx = 0; ball.vy = 0;
        } else {
          ball.stuck = true; ball.x = paddle.x + paddle.w/2; ball.y = paddle.y - ball.r - 1;
        }
      }

      if(isWin()){
        ball.stuck = true; ball.vx = 0; ball.vy = 0;
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    ctx.save();
    ctx.globalAlpha = 0.04;
    for(let x=0;x<W;x+=40){ ctx.fillRect(x,0,1,H); }
    for(let y=0;y<H;y+=40){ ctx.fillRect(0,y,W,1); }
    ctx.restore();

    for(let r=0;r<bricks.length;r++){
      for(let c=0;c<bricks[r].length;c++){
        const b = bricks[r][c];
        if(!b.alive) continue;
        const grad = ctx.createLinearGradient(b.x, b.y, b.x + b.w, b.y + b.h);
        grad.addColorStop(0, '#60a5fa');
        grad.addColorStop(1, '#7dd3fc');
        ctx.fillStyle = grad;
        roundRect(ctx, b.x, b.y, b.w, b.h, 6, true, false);
        ctx.globalAlpha = 0.12;
        roundRect(ctx, b.x+6, b.y+4, b.w-12, b.h-8, 4, true, false);
        ctx.globalAlpha = 1;
      }
    }

    ctx.fillStyle = '#e6eef8';
    roundRect(ctx, paddle.x, paddle.y, paddle.w, paddle.h, 8, true, false);

    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx.fillStyle = '#fff'; ctx.fill();
    ctx.closePath();

    ctx.font = '16px Inter, system-ui, sans-serif'; ctx.fillStyle = '#cbd5e1';
    if(lives <= 0){
      ctx.textAlign = 'center'; ctx.fillStyle = '#ffb4b4'; ctx.fillText('Game Over — Press Space or Start to Restart', W/2, H/2);
    } else if(isWin()){
      ctx.textAlign = 'center'; ctx.fillStyle = '#b7f5d0'; ctx.fillText('You Win! Press Space or Start to Play Again', W/2, H/2);
    } else if(ball.stuck){
      ctx.textAlign = 'center'; ctx.fillStyle = '#94a3b8'; ctx.fillText('Press Space to Launch', W/2, paddle.y - 30);
    }
  }

  function roundRect(ctx, x, y, w, h, r){
    const radius = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
    ctx.fill();
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  resetGame();
  loop();
})();
</script>
</body>
</html>
